#include "Renderer.h"

#include <iostream>

#include "glm/ext/scalar_constants.hpp"

static std::string DebugConvertSeverityToString(GLenum severity)
{
	switch (severity)
	{
	case GL_DEBUG_SEVERITY_LOW:
		return "GL_DEBUG_SEVERITY_LOW:Redundant state change performance warning, or unimportant undefined behavior";
	case GL_DEBUG_SEVERITY_MEDIUM:
		return
			"GL_DEBUG_SEVERITY_MEDIUM:Major performance warnings, shader compilation/linking warnings, or the use of deprecated functionality";
	case GL_DEBUG_SEVERITY_HIGH:
		return
			"GL_DEBUG_SEVERITY_HIGH:All OpenGL Errors, shader compilation/linking errors, or highly-dangerous undefined behavior";
	case GL_DEBUG_SEVERITY_NOTIFICATION:
		return "GL_DEBUG_SEVERITY_NOTIFICATION:Anything that isn't an error or performance issue.";
	}
}

static std::string DebugConvertSourceToString(GLenum Source)
{
	switch (Source)
	{
	case GL_DEBUG_SOURCE_API:
		return "GL_DEBUG_SOURCE_API: Calls to the OpenGL API";
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
		return "GL_DEBUG_SOURCE_WINDOW_SYSTEM: Calls to a window-system API";
	case GL_DEBUG_SOURCE_SHADER_COMPILER:
		return "GL_DEBUG_SOURCE_SHADER_COMPILER: A compiler for a shading language";
	case GL_DEBUG_SOURCE_THIRD_PARTY:
		return "GL_DEBUG_SOURCE_THIRD_PARTY:An application associated with OpenGL";
	case GL_DEBUG_SOURCE_APPLICATION:
		return "GL_DEBUG_SOURCE_APPLICATION:Generated by the user of this application";
	case GL_DEBUG_SOURCE_OTHER:
		return "GL_DEBUG_SOURCE_OTHER:Some source that isn't one of these";
	}
}

static std::string DebugConvertTypeToString(GLenum type)
{
	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR:
		return "GL_DEBUG_TYPE_ERROR: An error, typically from the API";
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
		return "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR	: Some behavior marked deprecated has been used";
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
		return "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: Something has invoked undefined behavior";
	case GL_DEBUG_TYPE_PORTABILITY:
		return "GL_DEBUG_TYPE_PORTABILITY:Some functionality the user relies upon is not portable";
	case GL_DEBUG_TYPE_PERFORMANCE:
		return "GL_DEBUG_TYPE_PERFORMANCE:Code has triggered possible performance issues";
	case GL_DEBUG_TYPE_MARKER:
		return "GL_DEBUG_TYPE_MARKER:Command stream annotation";
	case GL_DEBUG_TYPE_POP_GROUP:
		return "GL_DEBUG_TYPE_POP_GROUP:Group popping";
	case GL_DEBUG_TYPE_PUSH_GROUP:
		return "GL_DEBUG_TYPE_PUSH_GROUP:Group pushing";
	default:
		return "GL_DEBUG_TYPE_OTHER: Some type that isn't one of these";
	}
}

void Renderer::Clear()
{
	// Specify the color of the background
		glClearColor(0.07f, 0.13f, 0.17f, 1.0f);
		// Clean the back buffer and depth buffer
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}



void Renderer::Draw(const VertexArray& va, const IndexBuffer& ib, const Shader& shader) const
{
	shader.Bind();
	va.Bind();
	ib.Bind();
	glDrawElements(GL_TRIANGLES, ib.GetCount(),GL_UNSIGNED_INT, 0);
}

void Renderer::DrawCube(const Shader& shader)
{
	position =
	{ // COORDINATES                 
		
		//CUBE
		 0.5f, 0.5f,  0.5f,		1.f, 0.f, 0.f,	0.0f, 0.0f,
		-0.5f, 0.5f,  0.5f,		0.f, 1.f, 0.f,	5.0f, 0.0f, 
		-0.5f,-0.5f,  0.5f,		0.f, 0.f, 1.f,	0.0f, 0.0f,
		0.5f,  -0.5f,  0.5f,	1.f, 1.f, 1.f,	5.0f, 0.0f,
		// back
		 0.5,  0.5, -0.5,		1.f, 0.f, 0.f,	0.0f, 0.0f,
		-0.5,  0.5, -0.5,		0.f, 1.f, 0.f,	5.0f, 0.0f,
		 -0.5, -0.5, -0.5,		0.f, 0.f, 1.f,	0.0f, 0.0f,
		 0.5, -0.5, -0.5,		1.f, 1.f, 1.f,	5.0f, 0.0f
	};
	indices = {
		//CUBE
		0, 1, 2,
		2, 3, 0,

      // Right
      0, 3, 7,
      7, 4, 0,

      // Bottom
      2, 6, 7,
      7, 3, 2,

      // Left
      1, 5, 6,
      6, 2, 1,

      // Back
      4, 7, 6,
      6, 5, 4,

      // Top
      5, 1, 0,
      0, 4, 5,
	};
	VertexArray va;

	VertexBuffer vb(position.data(), 4 * position.size());

	VertexBufferLayout layout;
	layout.Push<float>(3);
	layout.Push<float>(3);
	layout.Push<float>(2);
	va.AddBuffer(vb, layout);

	IndexBuffer ib(indices.data(), indices.size()); 
	shader.Bind();
	va.Bind();
	ib.Bind();
	glDrawElements(GL_TRIANGLES, ib.GetCount(),GL_UNSIGNED_INT, 0);
}

void Renderer::DrawPyramid(const Shader& shader)
{
	position =
	{ // COORDINATES                 
	
		-0.5f, 0.0f,  0.5f,     0.f, 1.f, 0.f,	0.0f, 0.0f,
		-0.5f, 0.0f, -0.5f,     0.f, 0.f, 1.f,	5.0f, 0.0f,
		 0.5f, 0.0f, -0.5f,     1.f, 0.f, 0.f,	0.0f, 0.0f,
		 0.5f, 0.0f,  0.5f,     0.f, 1.f, 0.f,	5.0f, 0.0f,
		 0.0f, 0.8f,  0.0f,     0.f, 0.f, 1.f,	2.5f, 5.0f
	};
	indices = {
		//PYRAMID
		0, 1, 2,
		0, 2, 3,
		0, 1, 4,
		1, 2, 4,
		2, 3, 4,
		3, 0, 4
	
   };
	VertexArray va;

	VertexBuffer vb(position.data(), 4 * position.size());

	VertexBufferLayout layout;
	layout.Push<float>(3);
	layout.Push<float>(3);
	layout.Push<float>(2);
	

	va.AddBuffer(vb, layout);

	IndexBuffer ib(indices.data(), indices.size()); 
	shader.Bind();
	va.Bind();
	ib.Bind();
	glDrawElements(GL_TRIANGLES, ib.GetCount(),GL_UNSIGNED_INT, 0);
}

void Renderer::DrawSphere()
{
	//TODO:- IMPLEMENT DrawSphere();

}

void APIENTRY openglCallbackFunction(GLenum source,
                                     GLenum type,
                                     GLuint id,
                                     GLenum severity,
                                     GLsizei length,
                                     const GLchar* message,
                                     const void* userParam)
{
	std::cout << "[OpenGL ERROR]\nSource: " << DebugConvertSourceToString(source) << "\nType: " <<
		DebugConvertTypeToString(type) << "\nID: " << id << "\nSeverity: " << DebugConvertSeverityToString(severity) <<
		"\nMessage: " << message << std::endl;
	if(severity == GL_DEBUG_SEVERITY_HIGH)
		Break;
}

void glCheckError()
{
	glEnable(GL_DEBUG_OUTPUT);
	glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	glDebugMessageCallback(openglCallbackFunction, nullptr);
}
