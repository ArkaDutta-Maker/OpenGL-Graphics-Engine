#include "Renderer.h"

#include <iostream>

static std::string DebugConvertSeverityToString(GLenum severity)
{
	switch (severity)
	{
	case GL_DEBUG_SEVERITY_LOW:
		return "GL_DEBUG_SEVERITY_LOW:Redundant state change performance warning, or unimportant undefined behavior";
	case GL_DEBUG_SEVERITY_MEDIUM:
		return
			"GL_DEBUG_SEVERITY_MEDIUM:Major performance warnings, shader compilation/linking warnings, or the use of deprecated functionality";
	case GL_DEBUG_SEVERITY_HIGH:
		return
			"GL_DEBUG_SEVERITY_HIGH:All OpenGL Errors, shader compilation/linking errors, or highly-dangerous undefined behavior";
	case GL_DEBUG_SEVERITY_NOTIFICATION:
		return "GL_DEBUG_SEVERITY_NOTIFICATION:Anything that isn't an error or performance issue.";
	}
}

static std::string DebugConvertSourceToString(GLenum Source)
{
	switch (Source)
	{
	case GL_DEBUG_SOURCE_API:
		return "GL_DEBUG_SOURCE_API: Calls to the OpenGL API";
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
		return "GL_DEBUG_SOURCE_WINDOW_SYSTEM: Calls to a window-system API";
	case GL_DEBUG_SOURCE_SHADER_COMPILER:
		return "GL_DEBUG_SOURCE_SHADER_COMPILER: A compiler for a shading language";
	case GL_DEBUG_SOURCE_THIRD_PARTY:
		return "GL_DEBUG_SOURCE_THIRD_PARTY:An application associated with OpenGL";
	case GL_DEBUG_SOURCE_APPLICATION:
		return "GL_DEBUG_SOURCE_APPLICATION:Generated by the user of this application";
	case GL_DEBUG_SOURCE_OTHER:
		return "GL_DEBUG_SOURCE_OTHER:Some source that isn't one of these";
	}
}

static std::string DebugConvertTypeToString(GLenum type)
{
	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR:
		return "GL_DEBUG_TYPE_ERROR: An error, typically from the API";
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
		return "GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR	: Some behavior marked deprecated has been used";
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
		return "GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: Something has invoked undefined behavior";
	case GL_DEBUG_TYPE_PORTABILITY:
		return "GL_DEBUG_TYPE_PORTABILITY:Some functionality the user relies upon is not portable";
	case GL_DEBUG_TYPE_PERFORMANCE:
		return "GL_DEBUG_TYPE_PERFORMANCE:Code has triggered possible performance issues";
	case GL_DEBUG_TYPE_MARKER:
		return "GL_DEBUG_TYPE_MARKER:Command stream annotation";
	case GL_DEBUG_TYPE_POP_GROUP:
		return "GL_DEBUG_TYPE_POP_GROUP:Group popping";
	case GL_DEBUG_TYPE_PUSH_GROUP:
		return "GL_DEBUG_TYPE_PUSH_GROUP:Group pushing";
	default:
		return "GL_DEBUG_TYPE_OTHER: Some type that isn't one of these";
	}
}

void Renderer::Clear()
{
	// Specify the color of the background
		glClearColor(0.07f, 0.13f, 0.17f, 1.0f);
		// Clean the back buffer and depth buffer
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}



void Renderer::Draw(const VertexArray& va, const IndexBuffer& ib, const Shader& shader) const
{
	shader.Bind();
	va.Bind();
	ib.Bind();
	glDrawElements(GL_TRIANGLES, ib.GetCount(),GL_UNSIGNED_INT, 0);
}

void APIENTRY openglCallbackFunction(GLenum source,
                                     GLenum type,
                                     GLuint id,
                                     GLenum severity,
                                     GLsizei length,
                                     const GLchar* message,
                                     const void* userParam)
{
	std::cout << "[OpenGL ERROR]\nSource: " << DebugConvertSourceToString(source) << "\nType: " <<
		DebugConvertTypeToString(type) << "\nID: " << id << "\nSeverity: " << DebugConvertSeverityToString(severity) <<
		"\nMessage: " << message << std::endl;
	if(severity == GL_DEBUG_SEVERITY_HIGH)
		Break;
}

void glCheckError()
{
	glEnable(GL_DEBUG_OUTPUT);
	glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	glDebugMessageCallback(openglCallbackFunction, nullptr);
}
